# VLM 기반 타일 게임 에이전트 설계 스펙 (Nuxt + Python + LangChain)

> 목표: **Nuxt로 만든 타일 게임(대형 맵)**을 **이미지(10×10 뷰)만으로 관측**하는 **VLM(vision-language model)** 에이전트가,  
> **상/하/좌/우 이동 + 완료 선언**만으로 **다단 미션(“어디 들렀다가 어디 가라”)**을 수행하도록 만든다.  
> 에이전트는 **파일시스템 메모리**를 사용해 “이 길은 아니다” 같은 **부정적 지식**과 **지도를 누적**하며 탐색/경로계획을 한다.

---

## 1) 시스템 구성 요약

### 1.1 컴포넌트
- **환경(Environment): Nuxt 게임**
  - 전체 맵은 크지만 에이전트에게는 **10×10 시야(부분 관측)**만 제공
  - 사람용 UI(미션 입력, 로그 패널 등)는 유지
- **에이전트(Agent): Python**
  - 이미지 입력 가능한 **로컬 VLM**
  - **LangChain(또는 LangGraph)**로 툴 기반 에이전트 구성
- **메모리(Memory): 파일시스템**
  - 에이전트가 관측으로부터 **스스로 만든 내부표상**(지도/발견/막힘/방문)을 저장
  - **환경의 정답 상태(JSON)**는 **모델 입력으로 절대 제공하지 않음**
- **제어 채널(Control): WebSocket 권장**
  - `action -> ack -> frame` 형태로 턴 기반(step-based)으로 안정화

---

## 2) 에이전트의 툴 정의 (LangChain Tools)

> 핵심 원칙: 내부 구현은 비동기여도 좋지만, **툴 인터페이스는 “턴 단위로 끝나는 함수”**여야 한다.

### 2.1 필수 툴 3개 + (엄격 모드 추천) 1개
1) `set_mission(text: str) -> None`  
   - 사람이 입력한 미션(자연어)을 한 번 받아 내부 미션 큐로 변환하고 저장

2) `capture_view() -> image`  
   - **Agent View(10×10)** 영역만 캡처하여 반환  
   - *전체 화면 캡처 금지(노이즈/비용 증가)*: DOM element screenshot 또는 캔버스 프레임 추출 권장

3) `move(direction: Literal["UP","DOWN","LEFT","RIGHT"]) -> MoveResult`  
   - 한 칸 이동 요청을 보내고, **이동 완료 ack**를 받을 때까지 반환하지 않음  
   - `MoveResult`: `{step_id, moved: bool}` (벽이면 moved=false)

4) (추천) `declare_done() -> None`  
   - 에이전트가 “미션 완료”를 **스스로 선언**하는 액션  
   - 환경이 정답을 알려주지 않더라도, 실험/로그 채점은 가능

---

## 3) WebSocket 프로토콜(권장)

### 3.1 메시지 타입
- **Action (Agent -> Web)**
```json
{ "type": "action", "dir": "UP", "step_id": 123 }
```

- **Ack (Web -> Agent)**  
  이동 완료 및 이동 성공 여부
```json
{ "type": "ack", "step_id": 123, "moved": true }
```

- **Frame (Web -> Agent)**  
  관측 이미지 (base64 PNG/JPEG). `ack` 다음에 보내거나, `ack+frame` 합쳐도 됨.
```json
{ "type": "frame", "step_id": 123, "image_b64": "..." }
```

- **Mission (UI/Agent -> Web)**  
  UI의 “Send Command”와 에이전트의 set_mission을 같은 경로로 통일 가능
```json
{ "type": "mission", "text": "초록 배경 호랑이를 들렀다가 파란 배경 토끼로 가라" }
```

> 중요: WebSocket은 **컨트롤 채널**이다.  
> 관측은 끝까지 **이미지**로 유지한다(상태 JSON을 에이전트 입력으로 주지 않음).

---

## 4) 관측 제한: 10×10 부분 관측(Partial Observability)

### 4.1 전제
- 에이전트는 전체 맵을 볼 수 없고, **자기 주변 10×10**만 본다.
- 따라서 길찾기는 단순 경로계획이 아니라 **탐색 + 기억 + 재계획**이 된다.

### 4.2 에이전트 루프(턴 기반)
1) `capture_view()`로 10×10 스크린샷 획득  
2) VLM으로 현재 장면을 해석(Perception)  
3) 메모리 업데이트(Mapping)  
4) 다음 행동 결정(Planning)  
5) `move(dir)` 또는 `declare_done()`  
6) 반복

---

## 5) 다단 미션(Multi-goal Mission)

### 5.1 미션을 내부적으로 “미션 큐”로 고정
자연어 미션 예:
- “초록 배경 호랑이를 들렀다가 파란 배경 토끼로 가라”

내부 표현(예시):
1) `VISIT(type="tiger", bg="green")`
2) `VISIT(type="rabbit", bg="blue")`

### 5.2 두 단계 구조: Mission Manager → Navigator
- **Mission Manager(상위 뇌)**
  - 현재 목표(goal)를 선택
  - 목표 달성 판정이 성립하면 다음 goal로 전환
  - 모든 goal 완료 시 `declare_done()`
- **Navigator(하위 몸)**
  - 10×10 관측으로 탐색/지도작성/이동 수행
  - 목표 미발견 시 frontier 탐색
  - 목표 발견 시 landmarks 기반 접근

---

## 6) 엄격 모드: “도착(완료)도 스스로 판단한다”

### 6.1 목표 방문(VISIT) 판정 규칙(권장)
목표 `VISIT` 성공으로 인정하려면:
1) 목표(예: 초록 배경 호랑이)가 **플레이어 타일(중앙/근처)**에 있다고 판단  
2) 그 판단이 **연속 2~3 스텝** 일관  
3) (선택) 한 칸 옆으로 갔다가 돌아와도 동일 판정이면 신뢰도 상승

> 환경이 `done=true` 같은 정답 신호를 에이전트에게 제공하지 않는다.  
> 대신 에이전트는 `declare_done()`을 호출해 스스로 에피소드를 종료한다.

---

## 7) 파일시스템 메모리 설계

> “이 길은 아니다”를 감정이 아니라 **정보**로 저장한다.

### 7.1 저장 파일(추천 최소 세트)
1) `mission_state.json`
- 미션 큐, 현재 인덱스, 완료한 goal 목록

2) `map.json`
- 전역 지도(희소 표현 추천): `"x,y" -> tile_info`  
- tile_info는 에이전트가 이미지에서 추정한 내부표상(예: 장애물/빈칸/동물 후보)

3) `visited.json`
- `"x,y" -> count` (루프 방지, 비용 증가)

4) `blocked_edges.json`
- `"x,y,dir" -> true`  
- 예: (3, -1)에서 UP은 벽이라 실패했다 → 다시 시도하지 않기

5) `landmarks.json`
- 목표 후보 발견 기록: type/bg/추정좌표/confidence/last_seen_step

6) `notes.md`
- 에이전트의 짧은 추론 로그(가설/전략 변경 이유)

### 7.2 좌표계
- 시작 위치를 `(0,0)`으로 두고, 이동할 때마다 내부 좌표를 업데이트
- 10×10 관측을 현재 좌표 기준으로 “전역 지도”에 stitching(덧붙이기)

---

## 8) 탐색 전략(Exploration)

### 8.1 목표 미발견 시: Frontier 탐색
- **frontier = 알고 있는 영역과 아직 모르는 영역의 경계**
- 가장 가까운(혹은 정보량이 큰) frontier로 이동하여 시야 확장

### 8.2 목표 발견 시: 목표 접근
- landmarks에 기록된 좌표를 목표로 경로를 계획(A* 등)
- 막히면 `blocked_edges`를 갱신하고 우회 경로 탐색

---

## 9) 안정성 가드레일(실험을 가능하게 하는 장치)

- `max_steps` 설정(무한 루프 방지)
- 최근 N스텝에서 위치 변화가 없으면 전략 변경(탐색 방향 전환 등)
- `move()`는 반드시 ack 기반으로 동기화(렌더 타이밍 문제 방지)
- 관측 이미지 포맷(크롭/스케일)을 고정하여 학습/추론 안정화

---

## 10) 구현 로드맵(추천 순서)

1) **WS 제어 채널 구축**
   - action/ack/frame 3종 메시지로 턴 기반 루프 완성

2) **에이전트 툴( capture / move / set_mission / declare_done ) 구현**
   - 툴은 “한 턴에 끝나는 함수”로 만들기

3) **VLM 인식 포맷 고정**
   - 매 관측에서 VLM이 반환해야 하는 최소 구조(예: 10×10 기호 그리드 + 목표 후보 설명) 정의

4) **파일 메모리(지도/방문/막힘/랜드마크) 누적**
   - frontier 탐색 + 목표 접근 결합

5) **다단 미션 큐 처리**
   - VISIT 판정 성공 시 다음 목표로 전환

---

## 11) 성공 기준(내가 하고 싶은 것의 체크리스트)

- [ ] 관측은 10×10 이미지뿐이다(상태 JSON 입력 금지)
- [ ] 에이전트는 상/하/좌/우(+완료 선언)만으로 플레이한다
- [ ] “이 길은 아니다”를 `blocked_edges`, `visited`로 저장한다
- [ ] 다단 미션을 큐로 관리하고 순서대로 완료한다
- [ ] 완료(도착) 판정은 에이전트가 스스로 내린다(`declare_done`)
- [ ] 실패/루프에도 실험이 망가지지 않도록 가드레일이 있다

---

## 부록: 엄격함과 채점(선택)

- 에이전트에게 정답을 알려주지 않더라도, 연구/개발자는 내부적으로 채점할 수 있다.
- 단, 채점 결과를 에이전트 입력에 섞지 않는다(학습용 라벨로만 사용).

---

끝.
