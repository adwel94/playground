# 에이전트의 행동을 어디까지 제어해야하나

현재 사파리 에이전트 플로우 구조는 `명령 -> 이미지 확인 -> 행동`의 순차적 흐름을 강제하고 있습니다. 이에 대해 "이미지 확인 과정을 강제하지 않고, 이조차 에이전트의 자율적 판단에 맡길 수는 없을까?"라는 고민이 있었습니다.

## 1. 절차적 제어 vs 자율적 추론

### 절차적 제어 (현재 방식: 강제적 CaptureView)
*   **장점**: 
    *   **신뢰성**: 에이전트가 환각(Hallucination)에 빠지지 않고 항상 최신 시각 정보에 기반하여 사고하도록 강제합니다.
    *   **디버깅**: 에이전트의 모든 결정 직전에 스냅샷이 남으므로 문제 발생 시 원인 파악이 명확합니다.
*   **단점**: 
    *   **효율성 저하**: 주변 환경이 명확한 상황에서도 매번 캡처를 수행하므로 동작 속도가 느려지고 토큰 비용이 증가합니다.

### 자율적 추론 (대안: 에이전트가 도구 선택)
*   **장점**:
    *   **역동성**: 목표물이 멀리 있다면 여러 번의 `Move`를 연속으로 수행하여 빠르게 접근할 수 있습니다.
    *   **지능적 판단**: "필요할 때만 확인한다"는 고차원적인 전략 수립이 가능해집니다.
*   **단점**:
    *   **위험성**: 정보를 갱신하지 않고 이동하다가 장애물에 부딪히거나 목표를 지나치는 실수를 할 확률이 높아집니다.

## 2. 기술적 구현: WebSocketBridge의 역할

이러한 고민을 현실화할 수 있었던 핵심은 `WebSocketBridge`의 구현에 있습니다.

*   **비동기 속의 동기화**: 웹소켓은 기본적으로 비동기적이지만, 에이전트는 결과를 확인한 후 다음 행동을 결정해야 하는 '동기적 사고'가 필요합니다. `step_id`와 `Future` 객체를 이용한 브릿지 구조는 이 간극을 메워줍니다.
*   **메시지 가로채기(Interception)**: 에이전트가 클라이언트와 주고받는 내부적인 요청/응답은 브릿지가 중간에서 처리하고, 메인 루프에는 사용자 명령과 같은 상위 이벤트만 전달함으로써 시스템의 복잡도를 낮췄습니다.

## 3. 결론 및 향후 방향

결국 에이전트의 제어 수준은 **'안정성'과 '지능' 사이의 트레이드오프**입니다.

1. 초기 단계에서는 강제적인 절차를 통해 에이전트의 성공 사례(Success Path)를 확보합니다.
2. 이후 시스템 프롬프트를 완화하고, 행동 실패 시(예: 나무에 충돌) 상세한 피드백을 제공함으로써 에이전트가 **"언제 정보를 갱신해야 하는지"** 스스로 학습하게 유도하는 방향이 바람직해 보입니다.